[core-ML]
型τ
  τ ::= t | β | τ -> τ
型スキーマσ
  σ ::= τ|∀t.σ

項M,N
M,N ::=
      | x
      | M N
      | \x.M
      | let x = M in E
      | fix \x.M

[core-XML]

型τ
  τ ::= t | β | τ -> τ
型スキーマσ
  σ ::= τ|Πt.σ

M,N ::=
      | x
      | M N
      | \x:τ.M
      | M<τ>
      | \<t>.M
      | let x:σ = M in N

(\<t>.M) <τ> → M[t:=τ]
let x:Πt.σ = M in N → N[x:=M]

C ::= [] | M C | C N
    | \x:τ.C
    | C<τ>
    | let x:σ = C in N
    
[core-XML+record]
τ ::=
      | { l1:τ1;...;ln:τn }
M,N ::=
      | { l1=M1;...;ln=Mn }
      | #l


型推論

Γ |- #l ⇒ #l <X1> <X2> : X2->X1 where X1,X2 is fresh type variable

    Γ |- Mi ⇒ Mi' : τi    τi ≦ τ
-----------------------------------------------
Γ |- over τ of M1 |...| Mn ⇒
       over τ of τ1=>M1' |...| τn=>Mn' : τ


[型レベル評価]

C[M]→θC[M']

M→M',θ

(\<t>.M) <τ> → M[t:=τ],id
let x:Πt.σ = M in N → N[x:=M],id

#l <τ1> <{...;l:τ;...}> → #l,θ where θ=unify(τ,τ1)

over τ of τ'=>M → M,θ where θ=unify(τ,τ')
over τ of τ1=>M1|...|τn=>Mn 
→ over τ of τj=>Mj|...|τk=>Mk,id    1≦j≦i≦k≦n,unify(τ,τi),それ以外はfail





(over t->t->t of (+) | (+.)) 3 : Int -> Int
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

let print =
  fix \print.\x.(over t -> unit of
                 | print_string
                 | print_int
                 | ) x

型エラーになるはず
> #l {l = #l} (#l {l = 0})
#l <X1->X2> <{l:X1->X2}> {l = #l <X2> <X1>} (#l <X1> <{l:Int}>) {l = 0}
    ^^^                               Int       Int
    Int

(#l {l = #l}) (#l {l = 0})
^^^^^^^^^^^^^
#l (#l {l = 0})
   ^^^^^^^^^^^^      

#l 0


tupleのgeneralizeは個別に行う


let p = \<t0>.\x:t0.x,\<t1>.\x:t1.x      p:<t0>=><t1>=>(t0->t0,t1->t1)
                                         p:(<t0>=>t0->t0,<t1>=>t1->t1)

(\x,y.E) p
let x,y = p : <t0>=>t0->t0,<t1>=>t1->t1
let x = \<t0>.\<t1>.#0 (p <t0> <t1>) in
let y = \<t0>.\<t1>.#1 (p <t0> <t1>)
=>
let p = p in
let x = fst p in
let y = snd p 

[(\x,y.x) p]
=>
(\p.(\x.(\y.x) (snd p)) (fst p)) p

let x,y,z = p
let x,(y,z)


def id = \x.x;
=> \<t>.\x:t.x   : <t> => t -> t
--
id;
id <X>
=> \x:X.x
\<t>.id <t>

型式
k T T ...
T -> T

(T)


[動的型]

Int
Dtyp->Int
tcase (typeof x) of
  Int -> ...
* ... -> 


(t*t)

snd (t1,t2) -> t2
snd (t1,(t2,t3)) -> t2

let f = (1,2)
let x = fst f

a = { l:b }
r1 ::{ l1:b1; ... }
r2 ::{ l2:b2; ... }

r1

[組型]

  E1,...,En : T1,...,Tn

let b1,...,bn = E in E
    \b1,...,bn.E    : (T1,...,Tn) -> T

t1,t2,t3 = t1,(t2,t3)

let t1,t2,...

組型のオプション引数
\x,y,z ... .
fun (x,y,z...) ->
         ^^^^
     x,y,z,...

\x,y,z ...
<t>=>(t...)-> unit | 

tcase t of
    unit => 0
  | ,    => \<a>.\<b>.
  | ...  => \<t>
           z () | 

(a,b) -> a
, a (, b c) -->
, a b

(a,b)

cons a b

pair a b = Pair a b


 k T T
T,...,T
 T->T
pair a b = a,b

over add = \<t>.over t->t->t of (+) | (+.) | (^)

def double = \<t>.\x.add <t> x x

double <Int> 3

double (add <Int>) 3

add : \/t::[Int,Real,String].t -> t -> t
double : \/t::[Int,Real,String].t -> t

def evenodd =
    fix (\\eo.cons (\n.if (== n 0) true  (#1 eo (isub_ n 1)))
                   (\n.if (== n 0) false (#2 eo (isub_ n 1))))


変換する

[let x,y = E]
  ==> let xds,y = (\x:t0.x,\x:t1.x) : <t0>=><t1>=>T'  T'をx,yに分解する

fix (\f,g.E) -> (\f.E) (fix \f.E)
fst v
